/**
 * CVE Formatter
 * Converts NVD API responses to formatted output
 */

import type {
  NVDVulnerability,
  FormattedCVE,
  Severity,
  SearchSummary,
} from './types.js';
import { getBountyEstimate } from './api.js';

const SEVERITY_ORDER: Record<Severity, number> = {
  CRITICAL: 0,
  HIGH: 1,
  MEDIUM: 2,
  LOW: 3,
  UNKNOWN: 4,
};

export function formatCVE(vuln: NVDVulnerability): FormattedCVE {
  const cve = vuln.cve;

  // Get English description
  const descObj = cve.descriptions?.find((d) => d.lang === 'en');
  const description = descObj?.value || 'No description available';

  // Get CVSS v3.1 metrics (prefer v3.1, fallback to v3.0)
  const cvssV31 = cve.metrics?.cvssMetricV31?.[0];
  const cvssV30 = cve.metrics?.cvssMetricV30?.[0];
  const cvss = cvssV31 || cvssV30;

  const severity = (cvss?.cvssData?.baseSeverity || 'UNKNOWN') as Severity;
  const score = cvss?.cvssData?.baseScore ?? 'N/A';
  const attackVector = cvss?.cvssData?.attackVector || 'UNKNOWN';
  const attackComplexity = cvss?.cvssData?.attackComplexity || 'UNKNOWN';
  const privilegesRequired = cvss?.cvssData?.privilegesRequired || 'UNKNOWN';
  const userInteraction = cvss?.cvssData?.userInteraction || 'UNKNOWN';

  // Get CWEs
  const cwes =
    cve.weaknesses
      ?.flatMap(
        (w) => w.description?.filter((d) => d.lang === 'en').map((d) => d.value)
      )
      .filter((v): v is string => Boolean(v)) || [];

  // Get references (first 5)
  const references = cve.references?.slice(0, 5).map((r) => r.url) || [];

  // Check for exploit tags
  const hasExploit =
    cve.references?.some((r) =>
      r.tags?.some((t) => t.toLowerCase().includes('exploit'))
    ) || false;

  return {
    id: cve.id,
    description:
      description.substring(0, 500) + (description.length > 500 ? '...' : ''),
    severity,
    score,
    bountyEstimate: getBountyEstimate(severity),
    attackVector,
    attackComplexity,
    privilegesRequired,
    userInteraction,
    cwes,
    references,
    hasExploit,
    published: cve.published,
    lastModified: cve.lastModified,
  };
}

export function sortBySeverity(cves: FormattedCVE[]): FormattedCVE[] {
  return [...cves].sort(
    (a, b) =>
      (SEVERITY_ORDER[a.severity] ?? 4) - (SEVERITY_ORDER[b.severity] ?? 4)
  );
}

export function getSummary(
  cves: FormattedCVE[],
  totalResults: number
): SearchSummary {
  return {
    total: totalResults,
    shown: cves.length,
    critical: cves.filter((c) => c.severity === 'CRITICAL').length,
    high: cves.filter((c) => c.severity === 'HIGH').length,
    withExploit: cves.filter((c) => c.hasExploit).length,
  };
}

export function formatTextReport(
  cves: FormattedCVE[],
  summary: SearchSummary
): string {
  const lines: string[] = [];

  lines.push('# CVE Search Results\n');
  lines.push(`Found ${summary.total} total results (showing ${summary.shown})\n`);

  for (const cve of cves) {
    lines.push(formatSingleCVE(cve));
  }

  // Summary section
  lines.push('\n## Summary');
  lines.push(`- Critical: ${summary.critical}`);
  lines.push(`- High: ${summary.high}`);
  lines.push(`- With known exploits: ${summary.withExploit}`);

  if (
    summary.critical > 0 ||
    (summary.high > 0 && summary.withExploit > 0)
  ) {
    lines.push('\nHigh bounty potential detected!');
  }

  return lines.join('\n');
}

function formatSingleCVE(cve: FormattedCVE): string {
  const lines: string[] = [];

  lines.push(`\n### ${cve.id}`);
  lines.push('');
  lines.push(`**Severity**: ${cve.severity} (${cve.score})`);
  lines.push(`**Bounty Estimate**: ${cve.bountyEstimate}`);
  lines.push('');
  lines.push('**Description**:');
  lines.push(cve.description);
  lines.push('');
  lines.push('**Attack Vector**:');
  lines.push(`- Vector: ${cve.attackVector}`);
  lines.push(`- Complexity: ${cve.attackComplexity}`);
  lines.push(`- Privileges Required: ${cve.privilegesRequired}`);
  lines.push(`- User Interaction: ${cve.userInteraction}`);
  lines.push('');
  lines.push(`**CWE**: ${cve.cwes.length > 0 ? cve.cwes.join(', ') : 'Not specified'}`);
  lines.push('');
  lines.push(`**Exploit Available**: ${cve.hasExploit ? 'Yes' : 'Unknown'}`);
  lines.push('');
  lines.push('**References**:');
  for (const ref of cve.references) {
    lines.push(`- ${ref}`);
  }
  lines.push('');
  lines.push(`**Published**: ${new Date(cve.published).toLocaleDateString()}`);
  lines.push('---');

  return lines.join('\n');
}
